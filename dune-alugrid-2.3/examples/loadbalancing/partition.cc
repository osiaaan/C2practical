/******************************************************************************

  ALUGrid - a library providing a mesh manager supporting simplicial
  and hexahedral meshes, local grid adaptivity for use in parallel
  computations including dynamic load balancing.

  Copyright (C) 1998 - 2002 Bernhard Schupp
  Copyright (C) 1998 - 2002 Mario Ohlberger
  Copyright (C) 2004 - 2012 Robert Kloefkorn
  Copyright (C) 2005 - 2012 Andreas Dedner
  Copyright (C) 2010 - 2012 Martin Nolte

  The DUNE ALUGrid module is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License as
  published by the Free Software Foundation; either version 2 of
  the License, or (at your option) any later version.

  The ALUGrid library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License along
  with this program; if not, write to the Free Software Foundation, Inc.,
  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

******************************************************************************/

/******************************************************************************

  ALUGrid - a library providing a mesh manager supporting simplicial
  and hexahedral meshes, local grid adaptivity for use in parallel
  computations including dynamic load balancing.

  Copyright (C) 1998 - 2002 Bernhard Schupp
  Copyright (C) 1998 - 2002 Mario Ohlberger
  Copyright (C) 2004 - 2012 Robert Kloefkorn
  Copyright (C) 2005 - 2012 Andreas Dedner
  Copyright (C) 2010 - 2012 Martin Nolte

  The DUNE ALUGrid module is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License as
  published by the Free Software Foundation; either version 2 of
  the License, or (at your option) any later version.

  The ALUGrid library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License along
  with this program; if not, write to the Free Software Foundation, Inc.,
  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

******************************************************************************/

/** include config file generated by configure
 *  (i.e., know what grids are present, etc)
 *  this should always be included first */
#include <config.h>
/** standard headers **/
#include <iostream>
/** dune (mpi, field-vector and grid type for dgf) **/
#include <dune/common/mpihelper.hh>     
#include <dune/common/fvector.hh>        
#include <dune/common/timer.hh>        

#include <dune/alugrid/common/writeparalleldgf.hh>

#include "../piecewisefunction.hh"
#include "loadbalance.hh"

template <class Grid>
struct AssignRank
{
  AssignRank(const int rank) : rank_(rank) {}
  Dune::FieldVector<double,2> 
    initial(const Dune::FieldVector<double,Grid::dimensionworld> &) const
  {
    return Dune::FieldVector<double,2>(rank_);
  }
  private:
  int rank_;
};
// method
// ------
void partition ( const std::string name, int level )
{
  typedef Dune::GridSelector::GridType Grid;
  /* Grid construction ... */
  // create grid pointer and release to free memory of GridPtr
  Dune::GridPtr< Grid > gridPtr( name );

  Grid &grid = *gridPtr;

  typedef Grid::LeafGridView GridView;
  typedef GridView::IndexSet IndexSetType;
  GridView gridView = grid.leafView();
  const IndexSetType &indexSet = gridView.indexSet();
  size_t nofElParams = gridPtr.nofParameters( 0 );
  std::vector< double > eldat( 0 );

  if( nofElParams > 0 )
  {
    std::cout << "Reading Element Parameters:" << std::endl;
    eldat.resize( indexSet.size(0) * nofElParams );
    const Dune::PartitionIteratorType partType = Dune::All_Partition;
    typedef GridView::Codim< 0 >::Partition< partType >::Iterator Iterator;
    const Iterator enditer = gridView.end< 0, partType >();
    for( Iterator iter = gridView.begin< 0, partType >(); iter != enditer; ++iter )
    {
      const std::vector< double > &param = gridPtr.parameters( *iter );
      assert( param.size() == nofElParams );
      for( size_t i = 0; i < nofElParams; ++i )
      {
        eldat[ indexSet.index(*iter) * nofElParams + i ] = param[ i ];
      }
    }
  }

#if HAVE_ZOLTAN && USE_ZOLTANLB
  typedef ZoltanLoadBalanceHandle<Grid> LoadBalancer;
#else
  typedef SimpleLoadBalanceHandle<Grid> LoadBalancer;
#endif

  LoadBalancer ldb(grid);
  ldb.repartition();
  if (grid.comm().rank() == 0)
  {
    DGFWriter<GridView> writer(grid.leafView());
    writer.write(name,ldb,grid.comm().size());
  }
}

void method ( const std::string name, const char *outpath )
{
  typedef Dune::GridSelector::GridType Grid;
  /* Grid construction ... */
  // create grid pointer and release to free memory of GridPtr
  Grid* gridPtr = Dune::GridPtr<Grid>(name).release() ;

  Grid &grid = *gridPtr;
  grid.loadBalance();

  std::string outPath( outpath );
  const bool writeOutput = ( outPath != "none" ) ;
  if (!writeOutput)
    return;

  /* get view to leaf grid */
  typedef Grid::Partition< Dune::Interior_Partition >::LeafGridView GridView;
  GridView gridView = grid.leafView< Dune::Interior_Partition >();

  /* construct data vector for solution */
  typedef PiecewiseFunction< GridView, Dune::FieldVector< double, 2 > > DataType;
  DataType solution( gridView );
  solution.initialize( AssignRank<Grid>(grid.comm().rank()) );

  /* create VTK writer for data sequqnce */
  Dune::VTKSequenceWriter< GridView > vtkOut( gridView, "solution", outPath, ".", Dune::VTK::nonconforming );
  VTKData< DataType >::addTo( solution, vtkOut );
  VTKData< DataType >::addPartitioningData( grid.comm().rank(), vtkOut );
  vtkOut.write( 0.0 );
}
/***************************************************
 ** main program with parameters:                 **
 ** 1) number of problem to use (initial data...) **
 ** 2) number of global refinement steps          **
 ** 3) maximal level to use during refinement     **
 ***************************************************/
int main ( int argc , char **argv )
try
{
  /* initialize MPI, finalize is done automatically on exit */
  Dune::MPIHelper &mpi = Dune::MPIHelper::instance( argc, argv );
  
#if HAVE_ZOLTAN 
  float version;
  int rc = Zoltan_Initialize(argc, argv, &version);
  if (rc != ZOLTAN_OK){
    printf("sorry zoltan did not initialize successfully...\n");
    MPI_Finalize();
    exit(0);
  }
#endif

  if( argc < 3 )
  {
    /* display usage */
    if( mpi.rank() == 0 )
      std::cout << "Usage: " << argv[ 0 ] << " [partition] [dgf file] [Level]" << std::endl;
    return 0;
  }

  /* get level to use for computationa */
  const bool doPartition = atoi(argv[1]);
  const char* filename = argv[ 2 ];
  const int level = (argc > 3 ? atoi( argv[ 3 ] ) : 0);
  const char* path = (argc > 4 ) ? argv[ 4 ] : "./";

  if (doPartition)
  {
    partition( filename, level );
    mpi.getCollectiveCommunication().barrier();
  }

  std::stringstream newName;
  if (argc > 3)
    newName << filename << "." << level;
  else
    newName << filename << "." << mpi.size();
  method( newName.str(), path );

  /* done */
  return 0;
}
catch( const std::exception &e )
{
  std::cout << "STL ERROR: " << e.what() << std::endl;
  return 1;
}
catch( const Dune::Exception &e )
{
  std::cout << "DUNE ERROR: " << e << std::endl;
  return 1;
}
catch( ... )
{
  std::cout << "Unknown ERROR" << std::endl;
  return 1;
}
